# Voice Channels

This document describes the **Voice Channels** feature for Codec â€” real-time audio communication through persistent server voice channels powered by a custom mediasoup SFU.

## Implementation Status

| Phase | Description | Status |
|-------|-------------|--------|
| Phase 1 | Voice channels (server-side SFU, SignalR signaling, browser WebRTC) | âœ… Complete |
| Phase 2 | Deafen, per-user volume, push-to-talk | ðŸ“‹ Planned |
| Phase 3 | Direct voice calls from DMs | ðŸ“‹ Planned |
| Phase 4 | Voice infrastructure (Azure VM, Docker Compose, CI/CD) | âœ… Complete |
| Phase 5 | Video chat and screen sharing | ðŸ”® Future |

---

## Architecture

```
Browser                    API (ASP.NET Core)          SFU (mediasoup)
  â”‚                              â”‚                           â”‚
  â”‚â”€â”€â”€â”€ SignalR: JoinVoiceChannel â”€â”€>â”‚                       â”‚
  â”‚                              â”‚â”€â”€ POST /rooms/{id}/participants â”€â”€>â”‚
  â”‚                              â”‚â”€â”€ POST /rooms/{id}/transports â”€â”€â”€â”€>â”‚
  â”‚<â”€â”€ routerRtpCapabilities â”€â”€â”€â”‚                           â”‚
  â”‚<â”€â”€ sendTransportOptions â”€â”€â”€â”€â”‚                           â”‚
  â”‚<â”€â”€ recvTransportOptions â”€â”€â”€â”€â”‚                           â”‚
  â”‚<â”€â”€ members[] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                           â”‚
  â”‚                              â”‚                           â”‚
  â”‚â”€â”€â”€â”€ [connect send transport] â”€â”€>â”‚                       â”‚
  â”‚                              â”‚â”€â”€ POST /rooms/{id}/transports/{tid}/connect â”€â”€>â”‚
  â”‚â”€â”€â”€â”€ [produce audio] â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                       â”‚
  â”‚                              â”‚â”€â”€ POST /rooms/{id}/transports/{tid}/produce â”€â”€>â”‚
  â”‚<â”€â”€ producerId â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                           â”‚
  â”‚                              â”‚                           â”‚
  â”‚â”€â”€â”€â”€ SignalR: NewProducer broadcast to channel group      â”‚
  â”‚<â”€â”€ NewProducer event (other clients) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚â”€â”€â”€â”€ [consume other producer] â”€â”€>â”‚                      â”‚
  â”‚                              â”‚â”€â”€ POST /rooms/{id}/consumers â”€â”€â”€â”€â”€â”€>â”‚
  â”‚<â”€â”€ consumer parameters â”€â”€â”€â”€â”€â”€â”‚                           â”‚
```

**Key design points:**
- SignalR is used only for signaling (join, leave, new-producer notifications); audio flows directly over WebRTC via the SFU
- Each participant gets one **send transport** (microphone â†’ SFU) and one **recv transport** (SFU â†’ speakers)
- Codec = Opus audio only (Phase 1; video planned for Phase 5)
- The SFU is deployed on a dedicated Azure VM (not a container app) because mediasoup requires direct UDP socket access

---

## Data Model

### ChannelType Enum

```csharp
public enum ChannelType { Text = 0, Voice = 1 }
```

The `Channel` entity has a `ChannelType` property. Voice channels are created with `ChannelType.Voice`.

### VoiceState Entity

```csharp
public class VoiceState
{
    public int Id { get; set; }
    public int UserId { get; set; }
    public int ChannelId { get; set; }
    public string ParticipantId { get; set; } = string.Empty; // random UUID per session
    public string ConnectionId { get; set; } = string.Empty;  // SignalR connection
    public bool IsMuted { get; set; }
    public DateTimeOffset JoinedAt { get; set; }
}
```

Unique index on `UserId` prevents a user from joining multiple voice channels simultaneously. `ParticipantId` is the identifier used in the SFU room; it is a random UUID generated by the API at join time and is never reused.

---

## API

### REST Endpoints

| Method | Path | Auth | Description |
|--------|------|------|-------------|
| `POST` | `/servers/{serverId}/channels` | Member | Create channel; body includes `type: 1` for voice |
| `GET` | `/servers/{serverId}/channels` | Member | Returns channels with `channelType` field |

### SignalR Hub Methods (client â†’ server)

| Method | Parameters | Description |
|--------|-----------|-------------|
| `JoinVoiceChannel` | `channelId: string` | Join a voice channel; returns `routerRtpCapabilities`, `sendTransportOptions`, `recvTransportOptions`, `members[]` |
| `LeaveVoiceChannel` | â€” | Leave the current voice channel; cleans up SFU state and broadcasts `UserLeftVoice` |
| `ConnectTransport` | `transportId, dtlsParameters` | Finalize DTLS handshake for send or recv transport |
| `Produce` | `transportId, rtpParameters` | Start producing audio; returns `producerId` |
| `Consume` | `producerId, recvTransportId, rtpCapabilities` | Start consuming a remote producer; returns consumer parameters |
| `SetMuted` | `muted: boolean` | Update mute state; broadcasts `VoiceMuteChanged` to channel |

### SignalR Events (server â†’ client)

| Event | Payload | Description |
|-------|---------|-------------|
| `UserJoinedVoice` | `{ participantId, userId, displayName, avatarUrl, isMuted }` | Broadcast when a participant joins |
| `UserLeftVoice` | `{ participantId, userId }` | Broadcast when a participant leaves |
| `NewProducer` | `{ producerId, participantId }` | Sent to existing channel members when a new participant starts producing |
| `VoiceMuteChanged` | `{ participantId, isMuted }` | Broadcast when a participant mutes/unmutes |

---

## SFU Service

The SFU is a Node.js/Express application (`apps/sfu/`) built on **mediasoup v3**.

### REST API

| Method | Path | Description |
|--------|------|-------------|
| `GET` | `/health` | Health probe (no auth) |
| `POST` | `/rooms/:roomId/participants` | Create or join a room; returns `routerRtpCapabilities` |
| `POST` | `/rooms/:roomId/transports` | Create a WebRTC transport; returns transport options |
| `POST` | `/rooms/:roomId/transports/:transportId/connect` | Finalize DTLS handshake |
| `POST` | `/rooms/:roomId/transports/:transportId/produce` | Create a Producer; returns `producerId` |
| `POST` | `/rooms/:roomId/consumers` | Create a Consumer for a remote producer; returns consumer parameters |
| `DELETE` | `/rooms/:roomId/participants/:participantId` | Remove participant and close their transports |

### Security Hardening

- **`X-Internal-Key` authentication**: All `/rooms/*` routes require a shared secret header; timing-safe comparison via `crypto.timingSafeEqual`; the SFU process will refuse to start in `production` if `SFU_INTERNAL_KEY` is unset
- **Rate limiting**: 120 requests/minute per IP on all `/rooms/*` routes via `express-rate-limit`
- **JSON body size limit**: `express.json({ limit: '32kb' })` â€” RTP parameters never approach this
- **Transport ownership validation**: `/connect` and `/produce` routes require `participantId` in the request body and verify the transport belongs to that participant (prevents transport IDOR)
- **Producer room validation**: `/consumers` route verifies the requested `producerId` exists within the target room before calling `canConsume`

### Environment Variables

| Variable | Required in Production | Description |
|----------|----------------------|-------------|
| `SFU_PORT` | No (default `3001`) | HTTP port |
| `SFU_INTERNAL_KEY` | **Yes** | Shared secret for APIâ†’SFU auth (process exits if missing) |
| `ANNOUNCED_IP` | Yes | Public IP of the SFU VM for ICE candidates |
| `RTC_MIN_PORT` | No (default `40000`) | Start of UDP port range for RTP |
| `RTC_MAX_PORT` | No (default `40100`) | End of UDP port range for RTP |

---

## Infrastructure

### Voice VM

A dedicated Azure VM runs the SFU (mediasoup requires native UDP socket access that container apps don't support).

| Property | Value |
|----------|-------|
| SKU | `Standard_B2s` (2 vCPUs, 4 GiB RAM) |
| OS | Ubuntu 24.04 LTS |
| Provisioning | `cloud-init` (Docker, Docker Compose, `jq`) |
| Identity | System-assigned managed identity with `AcrPull` role |
| Public IP | Static (associated with NIC) |

### Network Security Group Rules

| Priority | Name | Port | Direction | Description |
|----------|------|------|-----------|-------------|
| 100 | `allow-ssh` | 22 (TCP) | Inbound | SSH access (restricted by `sshAllowedSourcePrefix` Bicep param) |
| 200 | `allow-turn-udp` | 3478 (UDP) | Inbound | STUN/TURN for WebRTC clients |
| 201 | `allow-turn-tcp` | 3478 (TCP) | Inbound | TURN over TCP fallback |
| 210 | `allow-coturn-relay` | 49152â€“49200 (UDP) | Inbound | coturn UDP relay range |
| 220 | `allow-mediasoup-webrtc` | 40000â€“40100 (UDP) | Inbound | mediasoup RTP/RTCP media plane |
| 300 | `allow-sfu-api` | 3001 (TCP) | Inbound | SFU HTTP API (source: Internet; tighten with VNet integration) |

### Bicep Parameters

| Parameter | Description |
|-----------|-------------|
| `voiceSfuInternalKey` | Shared secret for APIâ†’SFU auth; stored as Key Vault secret |
| `voiceSshAllowedSourcePrefix` | IP/CIDR allowed to SSH to the VM (default `'*'`; restrict to your egress IP in production) |
| `voiceVmAdminUsername` | VM admin user for SSH |
| `voiceVmAdminPublicKey` | SSH public key for the VM admin |
| `voiceTurnSecret` | TURN server shared secret (if using a coturn TURN server) |

### docker-compose.yml (on VM)

```yaml
services:
  sfu:
    image: ${ACR_SERVER}/codec-sfu:${IMAGE_TAG}
    restart: unless-stopped
    ports:
      - "3001:3001"
      - "40000-40100:40000-40100/udp"
    environment:
      ANNOUNCED_IP: "${ANNOUNCED_IP}"
      RTC_MIN_PORT: "40000"
      RTC_MAX_PORT: "40100"
      SFU_PORT: "3001"
      SFU_INTERNAL_KEY: "${SFU_INTERNAL_KEY}"

  coturn:
    image: coturn/coturn:latest
    restart: unless-stopped
    network_mode: host    # required for UDP relay port binding
    command: >
      --lt-cred-mech --use-auth-secret
      --static-auth-secret=${TURN_SECRET}
      --realm=codec-chat.com --listening-port=3478
      --min-port=49152 --max-port=49200
      --no-tls --no-dtls --log-file=stdout
```

`network_mode: host` is used on coturn so UDP relay ports bind directly on the host NIC. The SFU uses explicit port mapping instead.

### CI/CD â€” SFU Deployment

The `deploy-voice` job in `.github/workflows/cd.yml`:

1. Builds and pushes the `sfu` Docker image to ACR
2. SSHes to the voice VM via `azure/CLI` + `az vm run-command invoke`
3. Uses IMDS (Azure Instance Metadata Service) to authenticate with ACR â€” no `az` CLI needed on the VM:
   - Fetches AAD token from `http://169.254.169.254/metadata/identity/oauth2/token`
   - Exchanges it for an ACR refresh token via `https://{acr}/oauth2/exchange`
   - Runs `docker login` with the refresh token
4. Runs `docker compose pull && docker compose up -d`

Required GitHub Actions secrets: `VOICE_VM_HOST`, `VOICE_VM_SSH_KEY`, `VOICE_SFU_INTERNAL_KEY`, `VOICE_MEDIASOUP_ANNOUNCED_IP`.

---

## Frontend

### Key Files

| File | Description |
|------|-------------|
| `src/lib/services/voice-service.ts` | `VoiceService` class â€” mediasoup-client lifecycle (join, consume, mute, leave) |
| `src/lib/state/app-state.svelte.ts` | Voice state (`voiceChannelId`, `voiceMembers`, `isMuted`) and actions |
| `src/lib/services/chat-hub.ts` | SignalR hub methods and events for voice (`joinVoiceChannel`, `leaveVoiceChannel`, etc.) |
| `src/lib/components/channel-sidebar/VoiceChannel.svelte` | Voice channel row with participant list and join/leave |
| `src/lib/components/voice/VoiceControls.svelte` | Mute/deafen controls shown while in a voice channel |

### Join Flow

1. User clicks a voice channel row â€” `AppState.joinVoice(channelId)` is called
2. `VoiceService.join()` requests microphone access via `navigator.mediaDevices.getUserMedia` (throws immediately if denied â€” before any network work)
3. `hub.joinVoiceChannel(channelId)` is called over SignalR; the API creates a `VoiceState` record, creates SFU room/transports, and returns capabilities + transport options + existing member list
4. The mediasoup `Device` is loaded with `routerRtpCapabilities`
5. Send and recv transports are created; event handlers capture local `const` references (not `this.sendTransport`) to avoid null dereference if `leave()` is called concurrently
6. The microphone `Producer` is created
7. Existing members are consumed (deduplication via `consumedProducerIds` Set guards against the group-join/member-snapshot race)
8. `NewProducer` SignalR events from later joiners trigger `VoiceService.consumeProducer()`

### Microphone Permission Errors

| Error | User-facing message |
|-------|---------------------|
| `NotAllowedError` | "Microphone access was denied. Please allow microphone access in your browser settings and try again." |
| `NotFoundError` | "No microphone was found. Please connect a microphone and try again." |
| Other | "Could not access microphone: {error message}" |

### Known Limitations (Phase 1)

- Audio only (no video, no screen sharing)
- No deafen/undeafen (planned Phase 2)
- No per-user volume control (planned Phase 2)
- No push-to-talk (planned Phase 2)
- Single worker per SFU process (scales to ~500 concurrent participants before needing horizontal scaling)
- No TURN credential rotation (TURN secret is static)

---

## Phase 2 Planned Work

- **Deafen**: Pause all consumers client-side; broadcast `VoiceDeafenChanged` event
- **Per-user volume**: `gainNode` in Web Audio API per consumer track; no server changes needed
- **Push-to-talk**: Hold key â†’ `producer.resume()`, release â†’ `producer.pause()`; configurable keybind in User Settings
