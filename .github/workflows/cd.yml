name: cd

on:
  workflow_run:
    workflows: [ci]
    branches: [main]
    types: [completed]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

concurrency:
  group: cd-prod
  cancel-in-progress: false

env:
  RESOURCE_GROUP: rg-codec-prod
  ACR_NAME: acrcodecprod
  API_APP_NAME: ca-codec-prod-api
  WEB_APP_NAME: ca-codec-prod-web
  VOICE_VM_NAME: vm-codec-prod-voice

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'
    outputs:
      image-tag: ${{ github.sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and push API image
        run: |
          docker build -t ${{ env.ACR_NAME }}.azurecr.io/codec-api:${{ github.sha }} \
                        -t ${{ env.ACR_NAME }}.azurecr.io/codec-api:latest \
                        ./apps/api
          docker push ${{ env.ACR_NAME }}.azurecr.io/codec-api:${{ github.sha }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/codec-api:latest

      - name: Build and push Web image
        run: |
          docker build \
            --build-arg PUBLIC_API_BASE_URL=${{ secrets.PUBLIC_API_BASE_URL }} \
            --build-arg PUBLIC_GOOGLE_CLIENT_ID=${{ secrets.PUBLIC_GOOGLE_CLIENT_ID }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/codec-web:${{ github.sha }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/codec-web:latest \
            ./apps/web
          docker push ${{ env.ACR_NAME }}.azurecr.io/codec-web:${{ github.sha }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/codec-web:latest

      - name: Build and push SFU image
        run: |
          docker build -t ${{ env.ACR_NAME }}.azurecr.io/codec-sfu:${{ github.sha }} \
                        -t ${{ env.ACR_NAME }}.azurecr.io/codec-sfu:latest \
                        ./apps/sfu
          docker push ${{ env.ACR_NAME }}.azurecr.io/codec-sfu:${{ github.sha }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/codec-sfu:latest

  deploy-voice:
    runs-on: ubuntu-latest
    needs: build-and-push
    # Only runs when the voice VM is enabled. Set the VOICE_VM_ENABLED repository
    # variable to 'true' once the VM has been provisioned via infra/main.bicep.
    if: vars.VOICE_VM_ENABLED == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Substitute variables in docker-compose template
        env:
          ACR_SERVER: ${{ env.ACR_NAME }}.azurecr.io
          IMAGE_TAG: ${{ github.sha }}
          ANNOUNCED_IP: ${{ secrets.VOICE_VM_IP }}
          TURN_SECRET: ${{ secrets.VOICE_TURN_SECRET }}
          SFU_INTERNAL_KEY: ${{ secrets.VOICE_SFU_INTERNAL_KEY }}
        run: |
          envsubst '${ACR_SERVER} ${IMAGE_TAG} ${ANNOUNCED_IP} ${TURN_SECRET} ${SFU_INTERNAL_KEY}' \
            < infra/voice/docker-compose.yml \
            | base64 -w 0 > /tmp/compose-b64.txt

      - name: Write docker-compose.yml to VM
        run: |
          COMPOSE_B64=$(cat /tmp/compose-b64.txt)
          az vm run-command invoke \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.VOICE_VM_NAME }} \
            --command-id RunShellScript \
            --scripts "echo '${COMPOSE_B64}' | base64 -d > /opt/voice/docker-compose.yml && chmod 600 /opt/voice/docker-compose.yml"

      - name: Pull and start voice services
        run: |
          ACR_SERVER="${{ env.ACR_NAME }}.azurecr.io"
          az vm run-command invoke \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.VOICE_VM_NAME }} \
            --command-id RunShellScript \
            --parameters "ACR_SERVER=${ACR_SERVER}" \
            --scripts '
              set -e
              ACR_SERVER="$1"
              # Use managed identity via IMDS to get an AAD token for ACR, then exchange
              # it for an ACR refresh token — no Azure CLI required on the VM.
              AAD_TOKEN=$(curl -sf \
                "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https%3A%2F%2Fcontainerregistry.azure.net%2F" \
                -H "Metadata: true" | jq -r ".access_token")
              ACR_REFRESH=$(curl -sf -X POST "https://${ACR_SERVER}/oauth2/exchange" \
                -F "grant_type=access_token" \
                -F "service=${ACR_SERVER}" \
                -F "access_token=${AAD_TOKEN}" | jq -r ".refresh_token")
              echo "${ACR_REFRESH}" | docker login "${ACR_SERVER}" \
                -u 00000000-0000-0000-0000-000000000000 --password-stdin
              docker compose -f /opt/voice/docker-compose.yml pull
              docker compose -f /opt/voice/docker-compose.yml up -d --remove-orphans
            '

      - name: Verify SFU health
        run: |
          STATUS=$(az vm run-command invoke \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.VOICE_VM_NAME }} \
            --command-id RunShellScript \
            --scripts "curl -sf http://localhost:3001/health && echo OK" \
            --query "value[0].message" -o tsv 2>/dev/null || echo "FAILED")
          if [[ "$STATUS" != *"OK"* ]]; then
            echo "::error::SFU health check failed: $STATUS"
            exit 1
          fi
          echo "SFU health check passed"

  migrate-database:
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 10.0.x

      - name: Install EF Core tools
        run: dotnet tool install --global dotnet-ef --version 10.0.3

      - name: Restore and build
        working-directory: apps/api
        run: |
          dotnet restore Codec.Api/Codec.Api.csproj
          dotnet build Codec.Api/Codec.Api.csproj -c Release --no-restore

      - name: Build migration bundle
        working-directory: apps/api
        run: |
          dotnet ef migrations bundle \
            --project Codec.Api \
            --configuration Release \
            --no-build \
            --output ../../efbundle \
            --self-contained \
            --target-runtime linux-x64 \
            --force \
            --verbose

      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Open PostgreSQL firewall for runner
        id: firewall
        run: |
          RUNNER_IP=$(curl -s https://api.ipify.org)
          az postgres flexible-server firewall-rule create \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name psql-codec-prod \
            --rule-name AllowGitHubRunner \
            --start-ip-address "$RUNNER_IP" \
            --end-ip-address "$RUNNER_IP"
          echo "opened=true" >> "$GITHUB_OUTPUT"

      - name: Run migrations
        run: |
          CONNECTION_STRING=$(az keyvault secret show \
            --vault-name kv-codec-prod \
            --name ConnectionStrings--Default \
            --query value -o tsv)
          chmod +x ./efbundle
          ./efbundle --connection "$CONNECTION_STRING"

      - name: Close PostgreSQL firewall rule
        if: always() && steps.firewall.outputs.opened == 'true'
        run: |
          az postgres flexible-server firewall-rule delete \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name psql-codec-prod \
            --rule-name AllowGitHubRunner \
            --yes

  deploy:
    runs-on: ubuntu-latest
    needs: migrate-database
    environment: prod
    outputs:
      api-revision: ${{ steps.deploy-api.outputs.revision }}
      web-revision: ${{ steps.deploy-web.outputs.revision }}
    steps:
      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Ensure multiple revision mode
        run: |
          az containerapp revision set-mode \
            --name ${{ env.API_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --mode multiple
          az containerapp revision set-mode \
            --name ${{ env.WEB_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --mode multiple

      - name: Ensure container app registries
        run: |
          for APP in "${{ env.API_APP_NAME }}" "${{ env.WEB_APP_NAME }}"; do
            echo "Ensuring ACR registry on $APP..."
            az containerapp registry set \
              --name "$APP" \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --server ${{ env.ACR_NAME }}.azurecr.io \
              --identity system
          done

      - name: Deploy API staging revision
        id: deploy-api
        run: |
          SUFFIX="gh$(echo $GITHUB_SHA | cut -c1-7)n${{ github.run_number }}"
          RESULT=$(az containerapp update \
            --name ${{ env.API_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --image ${{ env.ACR_NAME }}.azurecr.io/codec-api:${{ github.sha }} \
            --revision-suffix "$SUFFIX" \
            --min-replicas 1 \
            -o json)
          REVISION_NAME=$(echo "$RESULT" | jq -r '.properties.latestRevisionName')
          echo "Created revision: $REVISION_NAME"
          echo "revision=$REVISION_NAME" >> "$GITHUB_OUTPUT"

      - name: Deploy Web staging revision
        id: deploy-web
        run: |
          SUFFIX="gh$(echo $GITHUB_SHA | cut -c1-7)n${{ github.run_number }}"
          RESULT=$(az containerapp update \
            --name ${{ env.WEB_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --image ${{ env.ACR_NAME }}.azurecr.io/codec-web:${{ github.sha }} \
            --revision-suffix "$SUFFIX" \
            --min-replicas 1 \
            -o json)
          REVISION_NAME=$(echo "$RESULT" | jq -r '.properties.latestRevisionName')
          echo "Created revision: $REVISION_NAME"
          echo "revision=$REVISION_NAME" >> "$GITHUB_OUTPUT"

      - name: Wait for staging revisions to be ready
        run: |
          for APP_REVISION in "${{ steps.deploy-api.outputs.revision }}" "${{ steps.deploy-web.outputs.revision }}"; do
            APP_NAME=$(echo "$APP_REVISION" | sed 's/--.*$//')
            echo "Waiting for revision $APP_REVISION..."
            for i in $(seq 1 60); do
              DETAIL=$(az containerapp revision show \
                --name "$APP_NAME" \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --revision "$APP_REVISION" \
                --query '{runningState:properties.runningState,healthState:properties.healthState,replicas:properties.replicas,active:properties.active}' \
                -o json 2>/dev/null || echo '{"runningState":"Unknown"}')
              STATUS=$(echo "$DETAIL" | jq -r '.runningState // "Unknown"')
              HEALTH=$(echo "$DETAIL" | jq -r '.healthState // "Unknown"')
              echo "  Attempt $i/60 — status=$STATUS health=$HEALTH detail=$DETAIL"
              if [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Stopped" ]; then
                echo "::error::Revision $APP_REVISION failed to start (status: $STATUS)"
                echo "--- Full revision details ---"
                az containerapp revision show \
                  --name "$APP_NAME" \
                  --resource-group ${{ env.RESOURCE_GROUP }} \
                  --revision "$APP_REVISION" 2>/dev/null || true
                echo "--- Recent container logs ---"
                az containerapp logs show \
                  --name "$APP_NAME" \
                  --resource-group ${{ env.RESOURCE_GROUP }} \
                  --tail 50 --type system 2>/dev/null || true
                exit 1
              fi
              # Accept any running state combined with a healthy (or undetermined) health state
              if [ "$STATUS" = "Running" ] || [ "$STATUS" = "Degraded" ] || [ "$STATUS" = "RunningAtMaxScale" ]; then
                if [ "$HEALTH" = "Healthy" ] || [ "$HEALTH" = "None" ]; then
                  echo "Revision $APP_REVISION is ready (status: $STATUS, health: $HEALTH)"
                  break
                fi
                echo "  Revision is running but health is $HEALTH, continuing to wait..."
              fi
              if [ "$i" = "60" ]; then
                echo "::error::Timed out waiting for revision $APP_REVISION (last status: $STATUS, health: $HEALTH)"
                echo "--- Full revision details ---"
                az containerapp revision show \
                  --name "$APP_NAME" \
                  --resource-group ${{ env.RESOURCE_GROUP }} \
                  --revision "$APP_REVISION" 2>/dev/null || true
                echo "--- Recent container logs ---"
                az containerapp logs show \
                  --name "$APP_NAME" \
                  --resource-group ${{ env.RESOURCE_GROUP }} \
                  --tail 50 --type system 2>/dev/null || true
                exit 1
              fi
              sleep 10
            done
          done

      - name: Verify staging revisions are healthy
        run: |
          for APP_REVISION in "${{ steps.deploy-api.outputs.revision }}" "${{ steps.deploy-web.outputs.revision }}"; do
            APP_NAME=$(echo "$APP_REVISION" | sed 's/--.*$//')
            DETAIL=$(az containerapp revision show \
              --name "$APP_NAME" \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --revision "$APP_REVISION" \
              --query '{runningState:properties.runningState,healthState:properties.healthState,replicas:properties.replicas,active:properties.active}' \
              -o json)
            echo "Pre-switch check for $APP_REVISION: $DETAIL"
            HEALTH=$(echo "$DETAIL" | jq -r '.healthState // "Unknown"')
            ACTIVE=$(echo "$DETAIL" | jq -r '.active // false')
            if [ "$HEALTH" != "Healthy" ] && [ "$HEALTH" != "None" ]; then
              echo "::error::Revision $APP_REVISION is not healthy (healthState: $HEALTH)"
              exit 1
            fi
            if [ "$ACTIVE" != "true" ]; then
              echo "::error::Revision $APP_REVISION is not active"
              exit 1
            fi
            echo "Revision $APP_REVISION verified: healthy=$HEALTH active=$ACTIVE"
          done

      - name: Switch traffic to new revisions
        run: |
          az containerapp ingress traffic set \
            --name ${{ env.API_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --revision-weight "${{ steps.deploy-api.outputs.revision }}=100"

          az containerapp ingress traffic set \
            --name ${{ env.WEB_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --revision-weight "${{ steps.deploy-web.outputs.revision }}=100"

      - name: Deactivate old revisions
        run: |
          OLD_API=$(az containerapp revision list \
            --name ${{ env.API_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "[?name!='${{ steps.deploy-api.outputs.revision }}' && properties.active].name" -o tsv)
          for rev in $OLD_API; do
            echo "Deactivating API revision: $rev"
            az containerapp revision deactivate \
              --name ${{ env.API_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --revision "$rev"
          done

          OLD_WEB=$(az containerapp revision list \
            --name ${{ env.WEB_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "[?name!='${{ steps.deploy-web.outputs.revision }}' && properties.active].name" -o tsv)
          for rev in $OLD_WEB; do
            echo "Deactivating Web revision: $rev"
            az containerapp revision deactivate \
              --name ${{ env.WEB_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --revision "$rev"
          done

      - name: Rollback — deactivate failed staging revisions
        if: failure()
        run: |
          az containerapp revision deactivate \
            --name ${{ env.API_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --revision "${{ steps.deploy-api.outputs.revision }}" 2>/dev/null || true
          az containerapp revision deactivate \
            --name ${{ env.WEB_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --revision "${{ steps.deploy-web.outputs.revision }}" 2>/dev/null || true

  smoke-test:
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get application FQDNs
        id: fqdns
        run: |
          API_FQDN=$(az containerapp show \
            --name ${{ env.API_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query properties.configuration.ingress.fqdn -o tsv)
          WEB_FQDN=$(az containerapp show \
            --name ${{ env.WEB_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query properties.configuration.ingress.fqdn -o tsv)
          echo "api-fqdn=$API_FQDN" >> "$GITHUB_OUTPUT"
          echo "web-fqdn=$WEB_FQDN" >> "$GITHUB_OUTPUT"

      - name: Smoke test API health
        run: |
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ steps.fqdns.outputs.api-fqdn }}/health/ready")
          if [ "$STATUS" != "200" ]; then
            echo "API health check failed with status $STATUS"
            exit 1
          fi
          echo "API health check passed (HTTP $STATUS)"

      - name: Smoke test Web health
        run: |
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ steps.fqdns.outputs.web-fqdn }}/health")
          if [ "$STATUS" != "200" ]; then
            echo "Web health check failed with status $STATUS"
            exit 1
          fi
          echo "Web health check passed (HTTP $STATUS)"
